<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>勇者侵入テスト</title>
  <link rel="stylesheet" href="../styles/styles.css" />
</head>
<body>
  <header>
    <h1>勇者侵入</h1>
  </header>
  <main>
    <div class="control-panel">
      <button id="nextTurn">次のターン</button>
      <span id="status"></span>
    </div>
    <div id="concept"></div>
    <div id="quote"></div>
    <div id="banter"></div>
    <canvas id="mapCanvas"></canvas>
  </main>
  <script src="../lib/utils.js"></script>
  <script type="module">
    import { generateMap } from '../lib/resourceManager.js';
    import { HeroAI } from '../scripts/hero_ai.js';
    import { MapRenderer } from '../scripts/map_renderer.js';
    import { TurnManager } from '../scripts/turn_manager.js';
    import config from '../data/game_config.json' assert { type: 'json' };
    import mapInfo from '../data/map.json' assert { type: 'json' };
    import heroParties from '../data/hero_parties.json' assert { type: 'json' };

    const map = generateMap(
      config.gridWidth,
      config.gridHeight,
      mapInfo.defaultTile
    );
    for (let x = 0; x <= 20; x++) {
      map.tiles[0][x].type = 'path';
    }
    for (let y = 0; y <= 20; y++) {
      map.tiles[y][20].type = 'path';
    }
    const renderer = new MapRenderer(document.getElementById('mapCanvas'), map);
    const tm = new TurnManager(config.stageCount, config.wavesPerStage);

    let heroes = [];
    let banter = [];
    let banterIndex = 0;

    async function startWave() {
      const party = heroParties[tm.getWaveIndex()];
      heroes = party ? party.members.map(() => new HeroAI(0, 0)) : [];
      document.getElementById('concept').textContent =
        party ? `コンセプト: ${party.concept}` : '';
      document.getElementById('quote').textContent =
        party ? `出発セリフ: ${party.departure_quote}` : '';
      banterIndex = 0;
      document.getElementById('banter').textContent = '';
      if (party && party.battle_chat_file) {
        try {
          const res = await fetch(`../data/${party.battle_chat_file}`);
          banter = await res.json();
        } catch (e) {
          banter = [];
        }
      } else {
        banter = [];
      }
    }

    function updateStatus() {
      const party = heroParties[tm.getWaveIndex()];
      const team = party ? party.team : '---';
      document.getElementById('status').textContent =
        `Stage ${tm.currentStage} Wave ${tm.currentWave} (${team}) - Phase: ${tm.phase}`;
    }

    tm.on('placement', async () => {
      // リソース吸収などの処理をここで行う
      await tm.nextPhase();
    });

    tm.on('waveStart', startWave);

    tm.on('heroTurn', () => {
      heroes.forEach(h => h.getNextMove(map));
      if (banter.length > 0) {
        document.getElementById('banter').textContent =
          banter[banterIndex % banter.length];
        banterIndex += 1;
      }
    });

    tm.on('transition', () => {
      heroes = [];
      banter = [];
      banterIndex = 0;
    });

    document.getElementById('nextTurn').addEventListener('click', async () => {
      await tm.nextPhase();
      renderer.render(heroes);
      updateStatus();
    });

    renderer.render();
    tm.start();
    updateStatus();

    window.dig = (x, y) => {
      if (map.tiles[y] && map.tiles[y][x]) {
        map.tiles[y][x].type = 'path';
        renderer.render(heroes);
      }
    };
  </script>
</body>
</html>

